![](git.jpg)

# Работа с Git 

## 1. Проверка наличия установленного Git.
В терминале выполнить команду `git version`.

Если Git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git

Загружаем последнюю версию Git с сайта https://git-scm.com/downloads.

Устанавливаем с настройками по умолчанию. 

## 3. Настройка Git

При первом использовании Git необходимо представиться. Для этого в терминале нужно ввести две команды: 
```
git config --global user.name "Имя пользователя"
git config --global user.email "Электронная почта пользователя"
```

## 4. Инициализация репозитория

Получить репозиторий можно двумя способами. 
1. В терминале переходит к папке, в которой хотим создать репозиторий. Выполняем команду `git init`.
1. Клонировать существующий репозиторий Git из любого места. `git clone <адрес репозитория>`.

## 5. Запись изменений в репозиторий

Каждый файл в рабочей папке (репозитории) может находиться в одном из двух состояний: под версионным контролем (отслеживаемый) и нет (неотслеживаемый).

Отслеживаемые файлы могут быть неизменёнными, изменёнными или подготовленными к коммиту.

## 6. Просмотр истории коммитов

Для просмотра истории коммитов используется команда `git log`. Данная команда перечисляет коммиты с их именами (хэш-кодами), именем и электронной почтой автора, датой создания и сообщением коммита.

## 7. Перемещение между сохранениями

Для перемещения между сохранениями используется команда `git checkout <name>`. Где `<name>` это либо непосредственно имя той фиксации к которой вы желаете перейти, либо имя ветки. Стоит отметить, что полное имя фиксации писать не обязательно. Достаточно только первых семи символов, которые вы можете узнать воспользовавшись командой `git log` с параметром `--oneline`.

В 2020 году в версии 2.27.0 в Git была введена команда `git switch <branch>`. Для переключения между ветками. Но про ветки это ниже.

## 8. Игнорирование файлов

Не все файлы одинаковы полезны для отслеживания. Например, графика -- она не особо влияет на код и незачем нагружать Git постоянной её фиксацией. Чтобы избавить Git от лишних тревог, следует создать файл `.gitignore`, где будут перечислены имена файлов/папок ненужных для индексации. Имена могут быть как полными, так и с масками. Вот три маски, которые могут вам пригодится: звездочка (__*__), вопросительный знак (__?__) и двойная звёздочка (__**__).

Звёздочка говорит, что на этом место может быть какая угодно комбинация символов (за исключением знака дроби -- __/__). Например, маска `*.psd` будет игнорировать любые файлы с расширением **PSD**.

Вопросительный знак говорит, что конкретно в этой позиции может быть любой символ (опять же кроме дроби). Например, маска `??_june.md` позволит игнорировать все файлы где в начале есть два неопределённых символа (скажем, числа), а дальше идёт фрагмент `_june.md`. 

Двойная звёздочка имеет пару вариаций. Если после неё идёт дробь и имя файла, то маска будет применятся ко всем таким файлам, где бы они ни находились. Например, маска `**/example` будет игнорировать все файлы `example` во всех возможных папках проекта.

Если же дробь идёт перед двойной звёздочкой, то будут игнорироваться все файлы в этой папке. Путь к папке рассчитывается от папки с конкретным файлом __.gitignore__. Например, маска `storage/**` оставит без внимания содержимое папки **storage**, находящейся в папке с файлом __.gitignore__, даже если там внутри вложено неопределённое количество папок и файлов. Все они будут игнорироваться.

## 9. Работа с ветками

Ветвление является важным инструментом как для коллективного труда над проектом, так и для возможности отладки кода без нанесения серьёзных увечий проекту.

Первоначально существует всего одна ветвь *master*. В глазах Git'а она не имеет каких-то особых, уникальных свойств. Но традиционно именно в неё сливают изменения из прочих ветвей. 

Чтобы увидеть в какой ветке вы находитесь в данный момент, достаточно взглянуть на строку которую выдаёт **bash** перед вводом команды: в самом конце, в скобках написано название ветви. Однако, можно воспользоваться и командой `git branch`. Она не только продемонстрирует вам текущую ветку (отмечена звёздочкой и выделена зелёным цветом), но и покажет имена других ветвей в алфавитном порядке.

Перед созданием новой ветки лучше бы зафиксировать все изменения. Иначе можно чего-то не досчитаться в новой ветке. Git не будет выдавать ошибку, если изменения не были сохранены, а вы создали новую ветвь. Он напомнит вам о фиксации только в момент переключения между ветками.

Создать новую ветвь можно посредством команды `git branch <branch>`. У этого способа есть один лёгкий недостаток. А именно: создав новую ветвь, вы всё ещё останетесь в исходной. То есть, вам придётся воспользоваться либо командой `git switch <branch>` (не работает в версиях Git ниже 2.27.0), либо старым добрым `git checkout <branch>`. Однако, если вам хочется чтобы создание ветви и перемещение в оную произошли в следствии одной единственной команды, то добавьте к `git checkout <branch>` ключ `-b`.

Когда работа в ветке завершится, вам придётся слить её содержимое с основной ветвью проекта. Переместитесь в неё предпочтительным для вас способом из предыдущего абзаца, и запустите команду `git merge <branch>`. Если всё произошло как задумано, то изменения вступят в силу в этой версии и появится сообщение о количестве изменений. Однако, если Git усмотрит конфликт версий, то поставит вас перед выбором какой из фрагментов корректный? Начало и конец будут отмечены значительным количеством знаков математического сравнения (`<` и `>`) (по семи штук кряду), и на границе конфликтующих фрагментов будет стоять шеренга из знаков равно (`=`). Редактор кода VScode способен такие казусы отслеживать и красиво подсвечивать. Помимо симпатичной гаммы, VScode предлагает четыре варианта разрешения конфликта: принять текущий вариант, принять имплантируемый вариант, принять оба варианта, разобраться в ручном режиме. Ещё в окне редактора появляется кнопка с предложением перейти в редактор слияния. Для новичка она скорее раздражающий фактор. Лучше не обращать на неё внимание, разобраться с конфликтом одним из четырёх предложенных способов, а затем применить уже классические `git add...` и `git commit -m...`.

Бывает так что подсветка у VScode не работает. Интернеты полны жалоб пользователей к разрабам VScode. Если обе галочки в настройках, как на рисунке, у вас стоят, а третья снята, то даже не знаю как с этим бороться.

![Настройки подсветки конфликта слияния: Settings > Extension > Merge Conflict > Merge-conflict ...](git-merge-conflict.png)

![Settings > Extension > Git > Git: Merge Editor ](git-merge-conflict-2.png)

Если ветвь вам больше не нужна, воспользуйтесь командой `git branch -d <branch>`. Обратите внимание на то что буква в ключе строчная. Если поставить там заглавную букву, то это будет форсированное удаление и буде вы что-то забыли слить с основной ветвью, Git вам про это уже не скажет. Будьте бдительны!

## 10. Удаление файлов из проекта или из отслеживания

Иногда нужно удалить файл. Для этого пригодится команда `git rm <name>`. После её применения файл навсегда покинет проект. Но бывает, что его нужно просто убрать из отслеживания, а вписывание в __gitignore__ не работает. Не работает оно потому что Git уже разок другой проиндексировал этот файл и будет бдительно за ним следить пока мы не применим команду `git rm --cached <name>`. Этот ключ позволит удалить файл именно из индекса проекта. Вот теперь внесение в __gitignore__ должно сработать.

## 11. Работа с удалёнными репозиториями
Вариант первый для работы с удалённым репозиторием это "подружить" новый репозиторий на сервисе GitHub с локальной версией репозитория. Все необходимые команды GitHub подскажет сразу же после создания удалённого репозитория. Например, вот так:

```
git remote add origin https://github.com/UserName/RemoteRepository.git
git branch -M main
git push -u origin main
```

Первая строка показывает локальному репозиторию адрес удалённого и говорит, что его зовут **origin**.

Вторая строка переименовывает главную ветку с **master** на **main**.

Третья строка выгружает локальную версию ветки **main** в удалённый репозиторий.

Вариант второй для работы с удалёнными репозиториями это копировать уже существующий проект и загрузить данную копию в локальный репозиторий. Об этом ниже.

### 11.1 Клонирование удалённого репозитория
Для клонирования удалённого репозитория используется команда `git clone <URL>`. Например вот так:
```
git clone https://github.com/UserName/RemoteRepository.git
```
В следствии этой команды репозиторий, указанный по ссылке, загрузится в вашу текущую папку. Но не торопитесь начинать работу с ней. Ибо репозиторий загрузится в текущую папку в виде другой папки, и для начала надо в неё войти командой `cd <Folder>`. 

Или же можно просто переоткрыть папку в редакторе VScode. Это избавит вас не только от необходимости использовать команду `cd`, но и от проблем с путями, если у вас, скажем, есть иллюстрации.

### 11.2 Развилка на чужом проекте
Однако, для полноценной командной работы, перед клонированием следует нажать на странице репозитория на GitHub кнопку **fork**. Почему-то все переводят на русский это слово как "вилка", что как бы не совсем верно. Это не вилка, а *развилка*. Как у дороги. С этого моменты "пути" проекта слегка расходятся. Зато открывается окно возможности в последствии им встретится через запрос на включение (**pull request**).

Нажатие на **fork** создаст в вашем профиле на GitHub полную копию проекта на данный момент. Его следует клонировать в ваш локальный репозиторий (как было описано выше), и создать *новую ветвь*, в которой вы и будете работать как в главной. Все заключительные изменения должны оказаться **не** в ветке **master** или **main**, а именно в этой *новой ветви*.

### 11.3 Команды *push* и *pull*
Для обмена информации между репозиториями используются две команды (на самом деле можно и больше, но этих двух достаточно): **толкай** и **тяни** -- `git push` и `git pull`. Для первого применения `git push` понадобятся детали, указывающий куде же именно нужно "заталкивать" файлы из локального репозитория. Например, так:
```
git push -u origin branch
```
Где **origin** это имя для удалённого репозитория, а **branch** имя ветви в нём. Но если вам лень, то можно схитрить и дать команду без каких либо параметров. Услужливый Git подскажет вам что же вы имели ввиду. Эту подсказку можно вырезать-вставить и запустить в терминале. Успех! 

Для получения и слияния содержимого удалённого репозитория с локальным используется команда `git pull`. Она объединяет в себе действие двух отдельных команд подряд. Это либо `git fetch` и `git rebase`, либо `git fetch` и `git merge`. Если при слиянии возникнут какие-либо конфликты, то потребуется участие пользователя как описывалось в главе 9.

### 11.4 Создание запроса на включение
Когда вы завершите свою часть работы над кодом, следует запросить у автора репозитория возможность загрузить вашу версию кода в главную ветвь проекта. В английском языке это называется "*pull request*". Дословный перевод на русский ("запрос на вытягивание") звучит несколько коряво, поэтому я воспользуюсь менее дословной версией: "запрос на включение". 

В Git существует способ сделать это через командную строку, но мы так не делали, поэтому я опишу процедуру подачи такого запроса через сайт GitHub.

После того как вы выгрузили вашу версию локального репозитория в удалённый, сайт GitHub может автоматически сгенерировать кнопку "**Compare & pull request**" ("Сравни и запроси включение"). А может и не сгенерировать. Не будем полагаться на изменчивое поведение веб-интерфейса, а перейдём к решению проблемы.

![Иллюстрация про вкладки](pullRequests.png)

Вверху страницы, начиная с левой стороны идут "вкладки" относящиеся к текущему удалённому репозиторию. На одной из них написано "**Pull requests**" ("Запросы на включение"). Перейдя в неё, вы обнаружите ряд кнопок, самая правая из которых зеленая и гласит: "**New pull request**" ("Новый запрос"). Она-то нам и нужна. Жмём и оказываемся на странице "**Comparing changes**" ("Сравнение изменений"). По умолчанию сравниваются главные ветви репозиториев, что как мы помним нам не нужно, ибо мы работали в новой ветке. В самой правой кнопке находится список, где следует выбрать вашу ветвь с финальной версией кода. 

После этого страница заполнится данными. Будет указано возможно ли автоматическое слияние. Ниже этого вы сможете добавить краткий комментарий и более полное описание ваших трудов (если вам лень, то будет использован комментарий из вашего последнего коммита). Ещё ниже будет краткая статистика по коммитам, файлам и соучастникам. В самом же низу окажется окно со сравнением изменений.

Если вас всё устраивает, смело жмите кнопку **Create pull request** ("Создать запрос на включение"). Эта манипуляция переведёт вас на страницу отправленного запроса. Здесь вы сможете отслеживать статус запроса и вести переписку с автором репозитория.